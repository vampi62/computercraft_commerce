global_createur = "vampi62"
global_repo_git = "https://github.com/vampi62/computercraft_commerce"
global_os_version = os.version()
if global_os_version == "CraftOS 1.8" then
	-- pas de changement
elseif global_os_version == "CraftOS 1.7" then
	-- dans craftos 1.7 require n'existe pas, la fonction shell.run similaire car elle utilise un environnement partag√©
	function require(fichier)
		shell.run(fichier..".lua")
	end
end

global_monitor_list = {} -- {side_monitor1=1,side_monitor2=1} -- remplacer la valeur par la taille du texte sur cette ecran


-- chargement des variables --
if not fs.isDir("config") then
	fs.makeDir("config")
end
global_config_http = "config/config.lua"
global_config_session = "config/session.lua"
global_config_panier = "config/panier.lua"
global_config_mdp_local = "config/mdpsha.lua"
global_config_table_http = "config/table.lua"
require("initvar")


local list = fs.list("config/")
for j = 1, #list do
	require("config/"..string.sub(list[j],1,-5))
end

global_local_config = {resync_time=5,delay_seconde=5,azerty=true,resync_liste=120}

global_min_y_page = 5
global_max_y_page = 15

global_http_enable = false
global_http_error_message = {}
global_local_error_message = {
	[1]="erreur - les deux mot de passe ne correspondent pas",
	[2]="erreur - un champ est vide",
	[3]="erreur - mot de passe incorrect",
	[4]="erreur - le serveur http ne fonctionne pas",
	[5]="erreur - pas de reponse du serveur http",
	[10]="succes - mot de passe bon",
	[11]="succes - mot de passe sauvegarder",
	[12]="succes - config reseau sauvegarder",
	[21]="erreur - la connexion au serveur API ne fonctionne pas",
	[22]="erreur - la connexion au serveur LUA ne fonctionne pas",
	[30]="succes - objet ajouter au panier",
	[31]="succes - objet retirer du panier",
	[32]="erreur - pas assez sur le compte pour le panier",
	[33]="erreur - les objet restant n'ont pas pu etre acheter",
	[34]="succes - tous les objet du panier ont bien ete commander"
}

-- init table d'echange entre les programmes --
-- receive_rednet

global_rednet_id = 0
global_rednet_message = "" -- string or table

-- touch
global_value_touch = {}

-- click
global_value_click = {}

-- scroll
global_limite_scroll_haut = false
global_limite_scroll_bas = false
global_scroll = 0

-- ntp
global_ntp = {seconde = 0,minute = 0,heure = 0,jour = 1,mois = 1,annee = 1974,sync = 5}

-- clavier
global_maint_clavier = ""
global_clavier = ""

-- affichage_term
global_refresh_term = false
global_term_objet_select = {}
global_term_objet_write = {}

-- affichage_mon
global_monitor_objet_select = {}
global_monitor_objet_write = {}

global_refresh_mon = {} -- {false,false} -- cette table a la meme taille que "global_monitor_list"
global_monitor_api = {} -- {function,function} -- fonction a utiliser pour les moniteurs ex: global_monitor_api[x].write() -- cette table a la meme taille que "global_monitor_list"

for k ,v in pairs(global_monitor_list) do
	global_monitor_api[k] = peripheral.wrap(k)
	global_refresh_mon[k] = false
end

global_new_version = {""}

global_page_visible = 0

global_histo_nav = {}
global_edit_variable = {}
global_clavier_maj = {lock=false,shift=false,altgr=false}
-- position min et max pour la generation du texte des tableaux

global_message = ""
global_compteur_tempo_message_http = 0

global_reapliquer_filtre = true
-- liste recuperer par http
global_liste = {}
global_liste["adresse"] = {}
global_liste["transaction"] = {}
global_liste["commande_client"] = {}
global_liste["commande_commerce"] = {}
global_liste["offre"] = {}
global_filtre_liste = {}
global_filtre_liste["adresse"] = {}
global_filtre_liste["transaction"] = {}
global_filtre_liste["commande_client"] = {}
global_filtre_liste["commande_commerce"] = {}
global_filtre_liste["offre"] = {}
global_filtre_liste["panier"] = {}
global_filtre = {}

-- chargement des fonctions --
local list = fs.list("fonction/")
for j = 1, #list do
	require("fonction/"..string.sub(list[j],1,-5))
end
reinitbox()
recup_http_config()

changementpage(0)
if global_login_pc ~= nil then
	changementpage(10)
end

if global_http_enable then
	sleep(1) -- pour eviter un melange entre le retour config et le retour login
	if global_session["pseudo"] ~= "" and global_session["mdp"] ~= "" then
		id_message_http = http_get("listuserdata&mdp="..global_session["mdp"].."&pseudo="..global_session["pseudo"],true)
		local temp_mdp_init = global_session["mdp"]
		if type(id_message_http) == "table" then
			global_session = id_message_http
			global_session["mdp"] = temp_mdp_init
		else
			global_session = {pseudo='', mdp='', compte=0, email='', defautadresse={nom='',type='',coo='',description=''}, nbr_offre=0, role='', last_login=''}
		end
		save_table_file(global_config_session, textutils.serialize(global_session), "global_session")
		id_message_http = nil
	end
end

-- chargement des programmes --
local list = fs.list("programme/")
for j = 1, #list do
	require("programme/"..string.sub(list[j],1,-5))
end

-- chargement des systeme --
local list = fs.list("backend/")
for j = 1, #list do
	require("backend/"..string.sub(list[j],1,-5))
end

-- chargement des page --
local list = fs.list("page/")
for j = 1, #list do
	require("page/"..string.sub(list[j],1,-5))
end

-- run prog --

os.setComputerLabel(global_systeme_nom.."-"..global_systeme_version)

function main()
	if not fs.exists("config/update.lua") then
		parallel.waitForAny(scroll, click, clavier, up_clavier, affichage_term, ntp, backend)
		sleep(5)
	else
		require("update")
	end
end
while true do
	local etat, error_mes = pcall(main)
	if not etat then
		local file = fs.open('log', 'a')
		file.writeLine(os.day()..':'..os.time()..' '..error_mes)
		file.close()
	end
	sleep(0.2)
end